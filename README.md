# Concurrency Playground — Баланс

## Цель проекта
Небольшой лабораторный проект для изучения и демонстрации **гонок данных (race conditions)** и способов их предотвращения на уровне приложения и базы данных.  
Проект моделирует операции с **балансом счёта**, чтобы показать, как конкурентные запросы могут нарушать инварианты и как их защищать.

---

## Основные понятия

- **Race Condition** — ситуация, когда результат операции зависит от порядка выполнения конкурирующих процессов.
- **Инвариант** — условие, которое должно оставаться истинным после любой последовательности операций.  
  *Пример*: баланс счета никогда не должен быть меньше 0.
- **Locking / Блокировки**
  - App-level (локи в Python)
  - DB-level (транзакции, `SELECT FOR UPDATE`)
- **Optimistic vs Pessimistic подходы**
  - Optimistic: предполагаем отсутствие конфликтов, проверяем и повторяем при необходимости
  - Pessimistic: блокируем ресурс до завершения операции

---

## Стек

- **Python 3.11+**
- **FastAPI** — веб-интерфейс для тестирования
- **PostgreSQL** — база данных
- **SQLAlchemy** — ORM / Core
- **pytest** — тесты на race condition
- **asyncio / threading** — для моделирования конкурентных операций

---

## Доменные объекты

- **Account**
  - `balance: int`
  - Методы:
    - `withdraw(amount)` — уменьшает баланс
    - `deposit(amount)` — увеличивает баланс
  - Инвариант: `balance >= 0`

---

## Структура проекта
concurrency_playground/
├── app/
│ ├── main.py # запуск сервиса
│ ├── db.py # подключение к БД
│ ├── models.py # ORM модели
│ ├── service.py # бизнес-логика операций с балансом
│ └── api.py # эндпоинты FastAPI
├── tests/
│ ├── test_race_naive.py # тестируем наивную реализацию
│ ├── test_with_lock.py # тестируем локи на уровне приложения
│ ├── test_db_lock.py # тестируем блокировки на уровне БД
│ └── test_optimistic.py # тестируем optimistic locking
└── README.md


---

## План итераций

1. **Наивная реализация**
   - Просто читаем баланс, проверяем, пишем обратно
   - Пишем тесты, которые ломают инвариант (`balance < 0`)

2. **App-level Locking**
   - Добавляем `threading.Lock` или `asyncio.Lock`
   - Тестируем, что конкуренция больше не ломает баланс

3. **DB-level: транзакции**
   - Используем транзакции, но без блокировок
   - Понимаем, когда race всё ещё возможен

4. **Pessimistic Locking**
   - `SELECT FOR UPDATE` в PostgreSQL
   - Гарантируем целостность данных на уровне БД

5. **Optimistic Locking**
   - Поля `version` или `updated_at`
   - Retry loop при конфликте

---

## Как запускать

*(позде: команды для запуска FastAPI, миграций и тестов)*

---

## Ценность проекта

- Учимся видеть и предотвращать race condition
- Прокачиваем навыки работы с инвариантами
- Поднимаем уровень инженерного мышления и понимания concurrency

